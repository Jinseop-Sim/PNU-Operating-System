# Limited Direct Execution
---
> 어떻게 우리는 효율적으로 CPU를 가상화 시킬 수 있을까?  
> OS는 __Time Sharing__ 을 통해 물리적인 CPU를 공유해야만 한다.  
- Issue
  - Performance : 어떻게 추가 Overhead 없이 가상화를 구현할 수 있을까?
  - Control : CPU의 제어권을 유지하며 Process를 효율적으로 어떻게 실행할 수 있을까?

## Direct Execution
> CPU에서 Program을 직접적으로(Direct) 실행시킨다고 생각해보자.
- OS
  1. Process List를 만든다.
  2. Program을 위한 Memory를 할당한다.
  3. Program을 Memory에 Load 시킨다.
  4. ```argc/argv```로 Stack을 할당한다.
  5. Register들을 비운다.
  6. ```main()``` 함수를 부른다.
- Program
  7. ```main()``` 함수를 실행시킨다.
  8. ```main()``` 함수에서 ```return```을 실행한다.
- OS
  9. Process의 Memory를 해제한다.
  10. Process List에서 삭제한다. (이미 실행했으니까)

- 그런데 이렇게만 OS를 사용하는 경우는, OS가 그저 라이브러리의 역할 밖에 하지 않는다!
  - Process List 저장 및 Memory 할당/해제

## Problem 1 : Restricted Operation
> 그럼 여기서 OS가 제한 없이 Library 역할 밖에 하지 않을 때의 문제가 발생한다.  
> 첫번째로, 만약 금지된 연산을 시행해버린다면 어떻게 처리해야 하는가?  

- 예를 들어 Disk에 I/O 동작을 할 때 문제가 생긴다던가,
- CPU나 Memory가 할당된 부분보다 더 많은 자원을 이용하려고 한다.
- 해결 방안 : 보호되는 상황에서의 제어권 전이를 하면 된다!(권한에 차이를 둔다)
  - User mode : 평소에는 User mode로 작동하며, 모든 접근 권한을 갖지 못한다.
  - Kernel mode : OS가 모든 자원에 접근할 수 있는 권한을 갖게 된다.

### System Call
> 위의 기능을 구현할 수 있는 핵심 기술이 바로 System Call!  
> Kernel이 기능적 핵심 자원에 접근을 할 수 있도록 한다.  
> 예를 들면, File System에 접근한다던지, Process를 생성하고 삭제하는 일이 있겠다.  

- Trap Instruction
  - Trap 명령어가 실행되면, Kernel로 권한이 전이된다.
  - User mode에서 Kernel mode로 바뀌며, 당연히 Privilege level도 올라간다.
- Return From Trap Instruction
  - Kernel의 작업이 끝난 이후, 다시 User mode의 Program으로 돌아간다.
  - Privilege Level은 다시 줄어든다.
- 그럼 OS는 어떤 종류의 Trap인지 어떻게 처리할 것인지 어떻게 알 것인가?
  - Trap table : Trap의 정보를 저장되어있는 Table이다.
  - Trap handler : Trap을 어떻게 처리할 것인가?
    - Program에서 Trap instruction이 실행되면 작동해야만 한다.
- System Call Number
  - 모든 System call에는 그 종류를 구분할 수 있는 Number가 반드시 부여된다.

### Limited Direction Execution의 통신 과정  
![image](https://user-images.githubusercontent.com/71700079/158307460-4761a6f8-5cf0-4a96-9ca8-48285cdba0a1.png)  
![image](https://user-images.githubusercontent.com/71700079/158307743-03687c04-eabd-4700-a03c-ee9677bdaf9f.png)  

