# Limited Direct Execution
---
> 어떻게 우리는 효율적으로 CPU를 가상화 시킬 수 있을까?  
> OS는 __Time Sharing__ 을 통해 물리적인 CPU를 공유해야만 한다.  
- Issue
  - Performance : 어떻게 추가 Overhead 없이 가상화를 구현할 수 있을까?
  - Control : CPU의 제어권을 유지하며 Process를 효율적으로 어떻게 실행할 수 있을까?

## Direct Execution
> CPU에서 Program을 직접적으로(Direct) 실행시킨다고 생각해보자.
- OS
  1. Process List를 만든다.
  2. Program을 위한 Memory를 할당한다.
  3. Program을 Memory에 Load 시킨다.
  4. ```argc/argv```로 Stack을 할당한다.
  5. Register들을 비운다.
  6. ```main()``` 함수를 부른다.
- Program
  7. ```main()``` 함수를 실행시킨다.
  8. ```main()``` 함수에서 ```return```을 실행한다.
- OS
  9. Process의 Memory를 해제한다.
  10. Process List에서 삭제한다. (이미 실행했으니까)

- 그런데 이렇게만 OS를 사용하는 경우는, OS가 그저 라이브러리의 역할 밖에 하지 않는다!
  - Process List 저장 및 Memory 할당/해제

## Problem 1 : Restricted Operation
> 그럼 여기서 OS가 제한 없이 Library 역할 밖에 하지 않을 때의 문제가 발생한다.  
> 첫번째로, 만약 금지된 연산을 시행해버린다면 어떻게 처리해야 하는가?  

- 예를 들어 Disk에 I/O 동작을 할 때 문제가 생긴다던가,
- CPU나 Memory가 할당된 부분보다 더 많은 자원을 이용하려고 한다.
- 해결 방안 : 보호되는 상황에서의 제어권 전이를 하면 된다!
  - User mode : 
  - Kernel mode : 
