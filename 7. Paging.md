# Paging
---
## Segmentation
- 이전까지의 Segmentation 방식을 복기해보자.
  - Segmentation은 Logical Segments의 크기가 모두 다르다.(Code, Heap, Stack)
  - 따라서 들쭉날쭉한 저장공간 때문에 __External Fragmentation__ 이 발생한다.
  - 시간이 지날수록(많이 저장할 수록) 더 많이 발생할 것이다.

## Paging
> Segmentation의 단점을 보완하기 위해 등장한 저장 방식인 Paging이다.  

- Segmentation은 순서에 상관없이 저장하긴 하지만 각 Segments들은 연속적인 덩어리로 저장이 되어야 한다.
  - 하지만 Paging은 Address Space를 일정한 크기로 모두 잘라서 Physical Memory에 할당하는 방식이다.
  - Physical Memory에서는 이 잘린 Page들을 Fixed Block Size의 Page Frame이라고 한다.
- Page의 크기는 2^n 으로 할당된다. (보통 512B ~ 8KB)
- Memory의 관리가 굉장히 쉬워진다.
  - OS는 몇 번 Page Block이 Free한지만 관리해주면 된다.
  - 즉, Page Table을 만들어서 관리해주고 Mapping 해주기만 하면 된다.
- 더 이상 External Fragmentation이 발생하지 않는다.  
![image](https://user-images.githubusercontent.com/71700079/162111635-08ba4667-6724-4c61-a872-9b6dc0faea60.png)  
![image](https://user-images.githubusercontent.com/71700079/162111749-c45a8461-be6a-46fa-b657-755b23e1e445.png)  

### Pros
- Pros
  - Flexibility : Address Space를 추상적으로 관리하기가 편하다.
    - Heap과 Stack 공간이 더 필요하다면, 필요한 만큼 더 Page를 삽입하기만 하면 된다.
  - Simplicity : Free 공간을 관리하기가 훨씬 쉬워졌다.

## Address Translation
> Segmentation은 Base와 Offset을 이용해서 실제 메모리 주소로 접근했다.  
> 그럼 Paging은 어떻게 접근할까?  

- Two Components
  - VPN : Virtual Page Number(Page Table Index)
  - Offset  
  ![image](https://user-images.githubusercontent.com/71700079/162112020-a541f576-9466-4832-98e0-382c9a446fbd.png)  
- Page Table은 Page Frame Number로 변환이 가능하다.
  - Physical Address는 <PFN, Offset>이 된다.
- Page Table
  - OS에 의해 관리된다.
  - VPN과 VFN을 Mapping 해준다.
  - One Page Table Entry(PTE)가 Page당 하나씩 존재한다.  
![image](https://user-images.githubusercontent.com/71700079/162112166-2a557048-0d35-4b60-8e71-1969a4823883.png)  
