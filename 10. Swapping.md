# Swapping
---
> Swapping이란?  
> Physical Memory에 담기엔 너무 큰 Program들이 존재한다.  
> 그 Program들을 필요할 때마다 Memory에 올리고 필요 없을 때 Disk에 Evict하는 동작을 Swapping이라고 한다.  

## Memory Hierarchy
> Swapping을 위해선, Memory Hierarhcy에서 추가적인 Level이 필요하다.  
> 현대에서는 Hard disk가 이를 담당하고 있다.  

![image](https://user-images.githubusercontent.com/71700079/165473718-a2dea965-7096-4ed8-8ddf-876ccfa61a33.png)  
- 각 Layer은 상위 계층의 Backing Store 역할을 한다.  

## How to Swap?
- Overlays
  - 개발자가 Code Level에서 동작을 작성해 수동으로 직접 하는 방식이다.
  - Code 개발 단계에서 개발자가 주의 깊게 메모리 관리를 해야할 필요성이 있다.
- Process-Level
  - Process의 Address Space 전체를 Backing Store(Disk)로 보내는 방식이다.
  - I/O나 어떤 Event를 기다리는 경우에, Process를 통째로 Backing Store로 내려버린다.
- Page-Level
  - Backing store로 Page 단위로 내려보낸다. (Swap out)
  - 필요한 부분을 Demand하면, 그 때 다시 들고 올라온다. (Swap in)

## Where to swap?
> Disk의 특정 영역에 Swap Partition을 만들어서 저장한다.  
> 보통 Swap space의 한 Block은 Page size와 동일하다.  

![image](https://user-images.githubusercontent.com/71700079/165475161-f4a0ef90-03ea-448a-815e-16b627583b8e.png)  
- Swap Space도 실제 메모리는 아니지만, 가상의 공간처럼 사용이 가능하다.

### Present bit
> Valid bit와는 별개로, Physical Memory에 존재하는 지 여부를 나타내는 bit  

- 1 : Physical Memory에 올라와서 존재하는 Page이다.
- 0 : Backing Store에 존재하는 Page로 현재 Physical Memory에 존재하지 않는다.

### Page Fault
- Major Page Fault : 해당 Page가 Physical Memory로 올라와있지(Swap in) 않은 상태이다.
  - OS가 Disk에서 Memory로 들고 올라와야 한다.(Page Fault Handler)
  - TLB Miss가 났을 때, Page의 Present Bit 검사 단계 까지는 MMU(Hardware)이 처리 가능하다.
  - 하지만 이후에 Disk에서 Memory로 Swap in하거나 Replace하는 것은 OS가 해야하는 일이다.
- 만약 Memory가 가득찼다면?
  - 누군가를 쫓아내서(Page out) 공간을 만들고 필요한 Page를 Swap in 시켜야 한다.

## Page Replacement Policy
- 만약 OS가 Physical Memory가 가득찼을 때만 Swap in/out을 하면 어떨까?
  - 가득찰 때 까지 기다렸다가 해버리면, Page를 하나 Swap해도 다시 가득찬 상태이기 때문에 또 Swap을 해야 한다.
  - 하나의 Page씩 Disk에 작성하고 메모리로 가져오고 하는 경우엔 엄청난 Overhead가 발생한다.
- Swap Daemon(Page Daemon)
  - 위와 같은 이유로 가득찰 때까지 기다리지 않는다.
  - Low / High Watermark Page
    - Free Page의 크기가 Low Watermark보다 낮아지기 시작하면
    - 필요 없는 Page들을 Free Page의 크기가 High Watermark 만큼 남을 때 까지 싹 다 쫓아낸다.

## What to Swap?
> 그럼 모든 Page들은 Swap이 필요할까?  

- Kernel Code / Data / Stack : Not Swapped, 항상 Memory에 존재해야만 한다.
- Page Table : Not swapped.
- User code : Dropped, Swap하지 않고 그냥 삭제해도 된다.
  - Why?) Code는 원래 Disk에 존재하며, Runtime에 수정될 일이 없으므로 삭제해도 된다.
- User Data : Dropped or Swapped
  - Why?) Data는 원래 Disk에 존재해서 삭제해도 되지만, Runtime에 수정이 되는 경우(Global, Static)엔 Swap을 해주어야 한다.
- User Heap/Stack : Swapped, Disk에 원본이 존재하지 않으므로 무조건 Swap해야 한다.
- File Mapped to User process : Drop or File System
  - Why?) File System에 원본이 존재한다. 따라서 삭제해도 되지만, 수정이 되는 경우엔 File System에 다시 저장해야 한다.
- Page Cache Pages : Drop or File system, 위와 같은 이유이다.

## Replacement Policy
### Cache Management
> 우리는 Swap Partition에 대해서 Physical Memory를 Cache 처럼 사용하고 있다.  
> 그럼 어떤 Replacement Policy가 좋은 지 비교를 해야하는데, 그 지표가 무엇일까?  

- AMAT(Average Memory Access Time) : (Hit ratio * Memory Access Time) + (Miss ratio * Disk Access time)
  - Cache Miss가 최소가 되는 Replacement Policy가 당연히 가장 좋은 Policy일 것!

### Optimal Replacement Policy
- 가장 먼 미래에 사용될 예정인 Page를 쫓아내는 것이 최적의 방법이다!
  - 하지만 이 방법은 미래를 알아야 하는 방법이라서 이론으로만 존재한다.
  - 성능 비교를 위한 기준점으로만 사용한다.

### Simple Policy : FIFO
- Page를 일종의 Queue에 넣어서 관리한다.
- Memory에 먼저 올라온 순서대로 쫓아내고 Swap한다.
  - 먼저 올라왔다고 해서 중요하지 않은 Page라는 보장이 없어서 실제로 쓰이지 않는다!
- __Belady's Anomaly__
  - 보통은 Cache의 용량이 커지면, Hit ratio는 올라가기 마련이다.
  - 하지만 FIFO 방식(Queue 방식)을 사용하는 경우엔 이상하게 Miss ratio가 올라가버린다!

### Simple Policy : Random
- 아무 Page나 Random하게 골라서 쫓아낸다.
- 물론 최선의 경우에는 최적 Policy와 같은 성능을 낼 것이다.
  - 하지만 너무 도박이다.

### LRU
> 과거를 사용하는 대표적 방법 2가지중 하나인 LRU(Least Recently Used).  
> 다른 하나는 LFU(Least Frequent Used)가 있다.  

- 과거에 사용한지 가장 오래된 것을 쫓아낸다.
- Temporal Locality 때문에 Optimal에 거의 근사한 성능을 낼 수 있다.
  - 하지만 완벽한 LRU를 구현하기란, 현실에서 거의 불가능하다.
  - Why?) Page가 접근될 때마다 언제 접근했는지 기록을 해야한다. 이는 엄청난 Overhead를 동반한다.
- FIFO와 반대로 __Stack Algorithm__ 에 의해 동작한다.
  - 이는 곧 Belady's Anomaly가 발생하지 않음을 의미한다.
- Frequency는 고려하지 않으며, 모든 Workload에 잘 들어 맞는 방식이라고는 할 수 없다.
